# Generator IR Next Steps

## Current State
- The builder lowers blocks, expression statements (including `yield*`), `while`, `do/while`, classic `for` loops (with labels), `if/else`, variable declarations, plain assignments (`target = yield <expr>`), simple `if (yield <expr>)` conditions, `return yield <expr>` statements, and `try/catch/finally` statements by emitting hidden slots and explicit IR instructions.
- Loop scopes track break/continue targets and now emit dedicated `BreakInstruction`/`ContinueInstruction` nodes so loop exits unwind active `finally` blocks before resuming, including across delegated `yield*` frames.
- `StoreResumeValueInstruction` consumes pending `.next/.throw/.return` payloads; `.throw`/`.return` flow through the interpreter before short-circuiting so try/catch/finally blocks can observe them, and a try-frame stack guarantees finally blocks execute during abrupt completion (including nested finalizers and mid-final `.throw/.return` overrides).
- Delegated `yield*` now awaits promise-returning iterator completions on both paths: `DelegatedYieldState.MoveNext` feeds promise-like `next/throw/return` results through `TryAwaitPromise`, and the IR `YieldStarInstruction` path now plumbs delegated `.throw/.return` completion (including async rejections) back through `HandleAbruptCompletion` and `CompleteReturn` so generators see the final completion record rather than the inner cleanup value.
- Tests `Generator_YieldStar_DelegatesValues`, `Generator_YieldStar_ReturnValueUsedByOuterGenerator`, `Generator_YieldStarReceivesSentValuesIr`, `Generator_YieldStarThrowDeliversCleanupIr`, `Generator_YieldStarReturnDeliversCleanupIr`, `Generator_YieldStarThrowContinuesWhenIteratorResumesIr`, `Generator_YieldStarThrowRequiresIteratorResultObjectIr`, `Generator_YieldStarReturnRequiresIteratorResultObjectIr`, `Generator_YieldStarThrowRequiresIteratorResultObjectInterpreter`, `Generator_YieldStarReturnRequiresIteratorResultObjectInterpreter`, `Generator_YieldStarThrowAwaitedPromiseIr`, `Generator_YieldStarThrowAwaitedPromiseInterpreter`, `Generator_YieldStarThrowPromiseRejectsIr`, `Generator_YieldStarThrowPromiseRejectsInterpreter`, `Generator_YieldStarReturnAwaitedPromiseIr`, `Generator_YieldStarReturnAwaitedPromiseInterpreter`, and `Generator_YieldStarReturnDoneFalseContinuesIr` now lock in delegated `.next/.throw/.return` semantics for synchronous iterators, promise-returning completions, and rejection propagation (IR + interpreter).
- IR now includes `JumpInstruction`, `StoreResumeValueInstruction`, and a delegated `YieldStarInstruction`, so `.next/.throw/.return` payloads are captured without replaying statements and delegated iterators remain on the IR fast path.
- Tests `Generator_IfConditionYieldIr` and `Generator_ReturnYieldIr` lock in IR semantics for `if (yield <expr>)` and `return yield <expr>` so resume payloads are threaded through the IR pending-completion model rather than via any replay-style execution.
- `for await...of` continues to run on the non-IR async/CPS pipeline, but tests `Generator_ForAwaitFallsBackIr`, `Generator_ForAwaitAsyncIteratorAwaitsValuesIr`, `Generator_ForAwaitPromiseValuesAreAwaitedIr`, and `Generator_ForAwaitAsyncIteratorRejectsPropagatesIr` verify that async iterators and promise-valued elements are awaited and that rejections surface as `ThrowSignal`s.
- All generator IR tests, including nested `try/finally` cases (`Generator_TryFinallyNestedThrowIr`, `Generator_TryFinallyNestedReturnIr`), are now green and exercise the IR pending-completion model.
- New tests `Generator_YieldStarNestedTryFinallyThrowMidFinalIr` and `Generator_YieldStarNestedTryFinallyReturnMidFinalIr` combine `yield*` with nested `try/finally` and mid-final `.throw/.return`, and `YieldStarInstruction` now preserves pending abrupt completions across multiple `finally` frames so later resumes override earlier ones without downgrading throws/returns.
- `Generator_ForOfLetCreatesNewBindingIr_UsesIrPlan` and `Generator_ForOfDestructuringIr_UsesIrPlan` now lock in that `for...of` with block-scoped bindings (including destructuring and closures) is hosted on the IR path.
- The replay-based generator path has been removed: `TypedGeneratorInstance` now requires `GeneratorIrBuilder.TryBuild` to succeed and throws a `NotSupportedException` with a detailed reason when IR construction fails.
- `Generator_SwitchStatementIr_UsesIrPlan` and `Generator_SwitchStatementSemanticsIr` now lock in IR-backed `switch` semantics inside generators for yield-free discriminants/tests, a single default clause in the final position, and simple trailing `break;` per case (with fallthrough preserved).
- `Generator_ForIncrementYieldIr_UsesIrPlan` now locks in IR support for `for` loops whose increment expression contains a single non-delegated `yield` (e.g. `i = i + (yield "step")`), using a hidden resume slot so the increment expression consumes the resume value on each iteration.
- `Generator_VariableInitializerWithMultipleYieldsIr_UsesIrPlan` now locks in IR support for variable initializers that are binary expressions whose left/right operands are simple (non-delegated) `yield` expressions with yield-free operands (e.g. `let value = (yield "a") + (yield "b");`), by rewriting the initializer to read from two hidden resume slots and emitting the corresponding yields in source order.
- Gap-coverage tests `Generator_ForIncrementMultipleYields_UnsupportedIr` and `Generator_SwitchStatement_UnsupportedIr` now document the remaining unsupported `yield` placements and complex `switch` layouts in generators (e.g. multiple yields in a single increment expression or non-tail/multiple defaults) by asserting clear failure reasons from `GeneratorIrDiagnostics`.
- `GeneratorIrDiagnostics` exposes lightweight counters for IR plan attempts/successes/failures, and `Generator_ForOfYieldsValuesIr_UsesIrPlan` asserts that plain `for...of` with `var` is always hosted on the IR path (no silent fallbacks). The `_UnsupportedIr` tests now exercise specific unsupported shapes without relying on global attempt counts, reducing flakiness when unrelated generators run in the same test session.
- `docs/GENERATOR_IR_LIMITATIONS.md` captures which generator constructs lower to IR, which ones intentionally fall back, and what follow-up work is still open.
- Date instances now use the constructor-created prototype chain instead of copying methods, fixing the `date-format-xparb.js` SunSpider failure caused by `this[func]()` seeing an undefined prototype method, and keeping dynamically-added `Date.prototype` methods visible to existing instances.
- A minimal `Function` constructor and `Function.call` helper have been added so patterns like `Function.call.bind(Object.prototype.hasOwnProperty)` behave as expected, and a stub `localStorage` object is exposed globally so `babel-standalone.js` can probe storage without throwing.
- Program-level and function-level function declarations are now hoisted via `HoistVarDeclarations`/`HoistFromStatement`, so cases like `exports.formatArgs = formatArgs;` before the `function formatArgs(...) {}` body in Babel’s bundled `debug` module resolve correctly rather than throwing `Undefined symbol` at module initialisation.
- `Date` built-ins now expose a more complete surface for common usage patterns: `Date.UTC` matches Node’s millisecond outputs (including the 0–99 year offset behaviour), instances support both local (`getFullYear` etc.) and UTC getters (`getUTCFullYear` etc.), and formatting helpers (`toISOString`, `toUTCString`, `toJSON`, `valueOf`) behave consistently with Node for ISO and UTC strings.

# Next Iteration Plan

1. **Split Generator IR into Lowering + Codegen**
   - Introduce a `GeneratorYieldLowerer.TryLowerToGeneratorFriendlyAst` pre-pass that rewrites complex `yield` placements (conditions, increments, assignments, declarations, and simple multi-yield expressions) into a normalized, generator-friendly AST or rejects unsupported shapes with clear reasons, so `SyncGeneratorIrBuilder` can assume a simplified surface.
   - Gradually migrate existing yield-rewrite helpers (`TryRewriteConditionWithSingleYield`, `TryLowerYieldingDeclaration`, `TryLowerYieldingAssignment`, etc.) from `SyncGeneratorIrBuilder` into the new lowering pass, keeping behaviour identical but reducing builder complexity.
2. **Grow IR Coverage for Remaining Unsupported Generator Shapes**
   - Use the `_UnsupportedIr` tests (complex `yield` in increments and complex `switch` layouts) as the driver for extending the normalized surface and the IR interpreter once lowering is in place.
   - As shapes become supported, flip the corresponding tests to `*Ir` / `*Ir_UsesIrPlan` variants and update `docs/GENERATOR_IR_LIMITATIONS.md`.
3. **Async Generator IR (Follow-Up)**
   - Replace the `AsyncGeneratorIrBuilder` placeholder with a real lowering path for `async function*`, reusing the generic suspend-point lowering patterns from the generator yield-lowering pass where possible so `await` and `yield` share the same normalization strategy.
   - Extend async iteration tests to assert IR usage via `GeneratorIrDiagnostics` once the async generator IR path is implemented.
