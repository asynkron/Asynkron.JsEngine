# Language Suite Next Steps

## Current State
- Direct eval inside class field initializers now inherits the enclosing `super` binding even when the base prototype lacks the requested property: `super.prop` now returns `undefined` rather than throwing, and regression tests cover eval-produced arrow functions assigning fields.
- Activity-based regression tests exist for the failing `Expressions_class_elements` shapes (instance/static/eval arrow cases) so we can iterate without running the full Test262 language suite every time.
- Generator functions now preserve previously supplied resume values when replaying class member computed names, so `yield` inside class accessor names works in both the parser (computed `in` expressions) and the runtime (see the updated `ClassComputedAccessorTests`). The Test262 suites still contain numerous failures (e.g., statement forms hit generator IR gaps and static/private accessor cases fail earlier in evaluation), but the new infrastructure unblocks further fixes.
- Class expressions whose binding names spell `await` (including escape sequences) now parse correctly in strict script goals; the `class-name-ident-await*.js` Test262 cases both pass.
- Generator iterator objects inherit from their function prototype (or `Object.prototype` fallback) so computed property names that call generator functions convert to property keys instead of throwing `TypeError: Cannot convert object to primitive value`.
- Class static blocks are parsed and executed (interleaved with other static elements), so `static-init-await-reference.js` now reaches runtime and observes `await` as an identifier within the block’s scope.
- Property assignments now reuse the active private-name scope when resolving `#name` keys, so static/private setters throw `TypeError` when invoked with receivers that lack the defining class’s brand (e.g., `private-static-setter-multiple-evaluations-of-class-realm.js` now passes).
- Parameter default expressions (including static generator methods) can read the per-call `arguments` object because the binding is created before parameter evaluation for both regular and generator functions (`params-dflt-gen-meth-static-ref-arguments.js` now passes).
- Class heritage validation now calls `IsConstructor` before accepting the `extends` value, so extending async arrows (or other non-constructors) throws the mandated `TypeError` (`heritage-async-arrow-function.js`).
- Generator methods (instance, static, object literal, and statement forms) now create a dedicated parameter environment whenever defaults/patterns are present, and generator evaluation contexts carry the correct blocked-var set. The `scope-*-gen-meth-paramsbody-var-open.js` matrix (strict & non-strict) passes, confirming parameter defaults no longer see body vars/lexicals.

## Next Iteration Plan
1. **Triage the remaining generator IR gaps** – revisit the `cpn-class-expr-*-yield` buckets (fields/accessors/static/private) and Annex B “contains supercall” shapes to nail down which AST patterns the current plan builder still rejects, then craft focused regression tests before extending the IR.
2. **Align compound assignment semantics with spec** – ensure property references are resolved exactly once, nullish bases throw `TypeError` before the RHS executes, and `with`/proxy/@@unscopables paths reuse the cached reference. Add regression tests mirroring the `language/expressions/compound-assignment/*` cases called out in `failing/languagetests.testsession`.
3. **Audit parser/evaluator helpers shared between eval + class fields** – in particular the `EvaluatePropertyAssignment` / `AssignmentReferenceResolver` paths – so private names, `arguments`, and `new.target` behave the same whether the initializer is literal or produced by direct/indirect eval.
