# Generator IR Next Steps

## Current State
- Generator yield lowering now normalizes declarations, assignments, returns, conditionals, and `for` conditions/increments into `__yield_lower_*` temps (`let __yield_lower...; __yield_lower... = yield ...;`) so `SyncGeneratorIrBuilder` only sees yield-free conditions/increments and recognizes those temp assignments as yield points to store resume payloads.
- Loop scopes track break/continue targets and now emit dedicated `BreakInstruction`/`ContinueInstruction` nodes so loop exits unwind active `finally` blocks before resuming, including across delegated `yield*` frames.
- `StoreResumeValueInstruction` consumes pending `.next/.throw/.return` payloads; `.throw`/`.return` flow through the interpreter before short-circuiting so try/catch/finally blocks can observe them, and a try-frame stack guarantees finally blocks execute during abrupt completion (including nested finalizers and mid-final `.throw/.return` overrides).
- Delegated `yield*` now awaits promise-returning iterator completions on both paths: `DelegatedYieldState.MoveNext` feeds promise-like `next/throw/return` results through `TryAwaitPromise`, and the IR `YieldStarInstruction` path now plumbs delegated `.throw/.return` completion (including async rejections) back through `HandleAbruptCompletion` and `CompleteReturn` so generators see the final completion record rather than the inner cleanup value.
- Tests `Generator_YieldStar_DelegatesValues`, `Generator_YieldStar_ReturnValueUsedByOuterGenerator`, `Generator_YieldStarReceivesSentValuesIr`, `Generator_YieldStarThrowDeliversCleanupIr`, `Generator_YieldStarReturnDeliversCleanupIr`, `Generator_YieldStarThrowContinuesWhenIteratorResumesIr`, `Generator_YieldStarThrowRequiresIteratorResultObjectIr`, `Generator_YieldStarReturnRequiresIteratorResultObjectIr`, `Generator_YieldStarThrowRequiresIteratorResultObjectInterpreter`, `Generator_YieldStarReturnRequiresIteratorResultObjectInterpreter`, `Generator_YieldStarThrowAwaitedPromiseIr`, `Generator_YieldStarThrowAwaitedPromiseInterpreter`, `Generator_YieldStarThrowPromiseRejectsIr`, `Generator_YieldStarThrowPromiseRejectsInterpreter`, `Generator_YieldStarReturnAwaitedPromiseIr`, `Generator_YieldStarReturnAwaitedPromiseInterpreter`, and `Generator_YieldStarReturnDoneFalseContinuesIr` now lock in delegated `.next/.throw/.return` semantics for synchronous iterators, promise-returning completions, and rejection propagation (IR + interpreter).
- IR now includes `JumpInstruction`, `StoreResumeValueInstruction`, and a delegated `YieldStarInstruction`, so `.next/.throw/.return` payloads are captured without replaying statements and delegated iterators remain on the IR fast path.
- Tests `Generator_IfConditionYieldIr` and `Generator_ReturnYieldIr` lock in IR semantics for `if (yield <expr>)` and `return yield <expr>` so resume payloads are threaded through the IR pending-completion model rather than via any replay-style execution.
- `for await...of` continues to run on the non-IR async/CPS pipeline, but tests `Generator_ForAwaitFallsBackIr`, `Generator_ForAwaitAsyncIteratorAwaitsValuesIr`, `Generator_ForAwaitPromiseValuesAreAwaitedIr`, and `Generator_ForAwaitAsyncIteratorRejectsPropagatesIr` verify that async iterators and promise-valued elements are awaited and that rejections surface as `ThrowSignal`s.
- All generator IR tests, including nested `try/finally` cases (`Generator_TryFinallyNestedThrowIr`, `Generator_TryFinallyNestedReturnIr`), are now green and exercise the IR pending-completion model.
- New tests `Generator_YieldStarNestedTryFinallyThrowMidFinalIr` and `Generator_YieldStarNestedTryFinallyReturnMidFinalIr` combine `yield*` with nested `try/finally` and mid-final `.throw/.return`, and `YieldStarInstruction` now preserves pending abrupt completions across multiple `finally` frames so later resumes override earlier ones without downgrading throws/returns.
- `Generator_ForOfLetCreatesNewBindingIr_UsesIrPlan` and `Generator_ForOfDestructuringIr_UsesIrPlan` now lock in that `for...of` with block-scoped bindings (including destructuring and closures) is hosted on the IR path.
- The replay-based generator path has been removed: `TypedGeneratorInstance` now requires `GeneratorIrBuilder.TryBuild` to succeed and throws a `NotSupportedException` with a detailed reason when IR construction fails.
- `Generator_SwitchStatementIr_UsesIrPlan` and `Generator_SwitchStatementSemanticsIr` now lock in IR-backed `switch` semantics inside generators for yield-free discriminants/tests, a single default clause in the final position, and simple trailing `break;` per case (with fallthrough preserved).
- `Generator_ForIncrementYieldIr_UsesIrPlan` now locks in IR support for `for` loops whose increment expression contains a single non-delegated `yield` (e.g. `i = i + (yield "step")`), using a hidden resume slot so the increment expression consumes the resume value on each iteration.
- `Generator_VariableInitializerWithMultipleYieldsIr_UsesIrPlan` now locks in IR support for variable initializers that are binary expressions whose left/right operands are simple (non-delegated) `yield` expressions with yield-free operands (e.g. `let value = (yield "a") + (yield "b");`), by rewriting the initializer to read from two hidden resume slots and emitting the corresponding yields in source order.
- Gap-coverage tests `Generator_ForIncrementMultipleYields_UnsupportedIr` and `Generator_SwitchStatement_UnsupportedIr` now document the remaining unsupported `yield` placements and complex `switch` layouts in generators (e.g. multiple yields in a single increment expression or non-tail/multiple defaults) by asserting clear failure reasons from `GeneratorIrDiagnostics`.
- `GeneratorIrDiagnostics` exposes lightweight counters for IR plan attempts/successes/failures, and `Generator_ForOfYieldsValuesIr_UsesIrPlan` asserts that plain `for...of` with `var` is always hosted on the IR path (no silent fallbacks). The `_UnsupportedIr` tests now exercise specific unsupported shapes without relying on global attempt counts, reducing flakiness when unrelated generators run in the same test session.
- `docs/GENERATOR_IR_LIMITATIONS.md` captures which generator constructs lower to IR, which ones intentionally fall back, and what follow-up work is still open.
- `docs/UNIFIED_CONTROL_FLOW_BUILDING_BLOCKS.md` outlines shared visitors/loop plans/await schedulers to deduplicate loop/yield/await handling across the lowerer, IR builders, and the typed evaluator.
- Shared `AstShapeAnalyzer` now owns yield/await detection and single-yield rewrites; generator lowering, generator IR building, and `TypedCpsTransformer` now consume it instead of bespoke `ContainsYield` visitors.
- Loop normalization scaffolding (`LoopPlan` + `LoopNormalizer`) is in place, and `SyncGeneratorIrBuilder` now builds while/do/for via LoopPlan; lowerer/evaluator loop runners still need to adopt it.
- Generator yield lowering now uses `LoopPlan` for while/do/for rewrites, and the typed evaluator runs while/do/for via `LoopPlan`, paving the way for shared loop handling across the stack.
- Iterator driver scaffolding exists (`IteratorDriverPlan`/`IteratorDriverState`); the generator IR executor now runs `for...of`/`for await...of` via shared `IteratorInit`/`IteratorMoveNext` instructions and the driver state instead of bespoke `ForOfState`/`ForAwaitStage` bookkeeping. The IR builder now constructs iterator bodies from `IteratorDriverPlan` but still hand-assembles the instruction sequence instead of using a shared template.
- Await handling is now centralized in `AwaitScheduler` so the evaluator and iterator drivers share the same blocking vs pending behaviour; semantics are unchanged, but this gives us one place to evolve into a non-blocking scheduler.
- Date instances now use the constructor-created prototype chain instead of copying methods, fixing the `date-format-xparb.js` SunSpider failure caused by `this[func]()` seeing an undefined prototype method, and keeping dynamically-added `Date.prototype` methods visible to existing instances.
- A minimal `Function` constructor and `Function.call` helper have been added so patterns like `Function.call.bind(Object.prototype.hasOwnProperty)` behave as expected, and a stub `localStorage` object is exposed globally so `babel-standalone.js` can probe storage without throwing.
- `instanceof` now follows `@@hasInstance`/`OrdinaryHasInstance` semantics (including the well-known `Symbol.hasInstance`), `Function.prototype[@@hasInstance]` throws when `prototype` is non-object, and the `LanguageTests.Expressions_instanceof` suite is green aside from the explicitly excluded prototype-getter and TCO cases.
- A dynamic call-depth guard (default 1000) now wraps JS invocations to fail fast on runaway recursion; promise callbacks still recurse synchronously and need the guard propagated through the promise scheduler to cover async iterator edge cases.
- Promise handler invocation is now scheduled onto the engine event queue instead of recursing synchronously, so deep promise chains (including async iterator helpers) unwind the C# call stack between steps instead of overflowing.
- Program-level and function-level function declarations are now hoisted via `HoistVarDeclarations`/`HoistFromStatement`, so cases like `exports.formatArgs = formatArgs;` before the `function formatArgs(...) {}` body in Babel’s bundled `debug` module resolve correctly rather than throwing `Undefined symbol` at module initialisation.
- `Date` built-ins now expose a more complete surface for common usage patterns: `Date.UTC` matches Node’s millisecond outputs (including the 0–99 year offset behaviour), instances support both local (`getFullYear` etc.) and UTC getters (`getUTCFullYear` etc.), and formatting helpers (`toISOString`, `toUTCString`, `toJSON`, `valueOf`) behave consistently with Node for ISO and UTC strings.
- `async function*` is now wired into the typed evaluator: async generator functions are created via `AsyncGeneratorFactory` / `AsyncGeneratorInstance`, which internally reuse the sync generator IR plan and wrap the iterator protocol (`next`/`return`/`throw`) in Promises so async generator tests (covering loops, `switch`, `try/catch/finally`, and `yield*`) run on the IR path.
- `await` expressions in typed AST and async iterator helpers rely on a shared `TryAwaitPromise` helper that synchronously blocks on promise-like values; `EvaluateAwait` now delegates to `TryAwaitPromise` so `await` inside `async function*` bodies (including in `while` / `do/while` loops) resolves promise-like values before each `yield`, and async generator tests `AsyncGenerator_AwaitsBeforeYield` / `AsyncGenerator_WhileAndDoWhileWithAwaitAndYield` are green.

# Next Iteration Plan

> Before we do any way, ensure to verify the below tasks against the actual source code, are they still true?

1. **Grow IR Coverage for Remaining Unsupported Generator Shapes**
   - Use the `_UnsupportedIr` tests (complex `yield` in increments and complex `switch` layouts) as the driver for extending the normalized surface and the IR interpreter once lowering is in place.
   - As shapes become supported, flip the corresponding tests to `*Ir` / `*Ir_UsesIrPlan` variants and update `docs/GENERATOR_IR_LIMITATIONS.md`.
2. **Async Generator IR + Non-Blocking Await (Real Thing)**
   - Async generators now reuse the sync generator IR plan via `TypedGeneratorInstance`, surface pending promises from `await` expressions and `for await...of` loops through `AsyncGeneratorStepResult.Pending`, and resume via `AsyncGeneratorInstance` using the engine’s event queue. Nested awaits inside async generators (including `__delay`) and `for await...of` inside async generator bodies are hosted on the non-blocking IR path.
   - **Unify async iteration paths**
     - Replace remaining uses of the blocking `TryAwaitPromise` helper in non-IR async iteration (`EvaluateForAwaitOf`, CPS async helpers) with the non-blocking `TryAwaitPromiseOrSchedule` + event-queue model so plain `async function` + `for await...of` can safely use `__delay(1)` without thread blocking.
   - **Diagnostics and tests**
     - Extend `AsyncGeneratorTests` and `AsyncIterationTests` with cases that detect real non-blocking behaviour (including `__delay(1)` in both async functions and async generators) and add async-aware diagnostics so we can assert that async generators and `for await...of` loops are using the IR + pending-promise executor rather than any legacy blocking behaviour.
3. **Broaden lowerer coverage and tests**
   - Add unit tests around the normalized conditional/`for` rewrites and any remaining multi-yield expressions to lock in the new lowering surface and guard against regressions as more IR shapes are added.
4. **Unify control-flow building blocks**
   - Next steps from `docs/UNIFIED_CONTROL_FLOW_BUILDING_BLOCKS.md`: finish unifying iterator handling by reusing the shared `IteratorDriverPlan` template in the IR builder (instead of assembling per-iteration blocks manually), then move on to non-blocking await scheduling and the shared rollback/loop helpers. Await handling is now centralized via `AwaitScheduler`, and async generators surface pending promises to `AsyncGeneratorInstance`; plain async functions/other iterator paths still need the non-blocking scheduler wired in.
5. **Harden recursion/overflow handling**
   - Promise callbacks now run via the event queue to avoid synchronous recursion. Follow up by threading call-depth diagnostics through the async scheduler so remaining re-entry paths are covered and we can add a regression test.

---

## Annex B Scope Modes

### Current State

> Before we do any way, ensure to verify the below tasks against the actual source code, are they still true?

- `EvaluationContext` now tracks `ScopeMode` frames (`Strict`, `Sloppy`, `SloppyAnnexB`), and `RealmState.CreateContext` produces pre-scoped strict contexts for host helpers so sloppy vs Annex B semantics flow through the scope stack.
- The realm context factory now supports cancellation/execution options, and all runtime helpers (program + function invocation) use it instead of `new EvaluationContext`, so scope stacks are created uniformly.
- Standard library helpers (String/Number/JSON/Array/Function), typed arrays, and `JsArgumentsObject` all rely on the realm factory instead of hand-rolling `EvaluationContext`, so coercion helpers automatically inherit the correct strict/Annex B behaviour.
- Generator execution contexts (both IR-backed and fallback) use the same factory, and Annex B block instantiation during hoisting now keys off `context.CurrentScope.AllowAnnexB` instead of global option checks.
- `AnnexBOptionsTests` now cover lexical/parameter blocking, loop-scoped functions, nested eval inside loops, `switch`/`try` bodies, and `with`-scoped helpers so Annex B toggles are validated across common control-flow shapes.
- `with` environments now participate in identifier deletion: `DeleteExpression` looks up bindings through the scope stack and `JsEnvironment.DeleteBinding` removes properties from the active `with` object (or reports non-configurable failures). Targeted `Statements_with` test262 runs dropped from 79 failing cases to 67, isolating the remaining regressions to `@@unscopables`/proxy semantics.
- `JsEnvironment` exposes `HasProperty`/`HasVisibleWithBinding` so `AssignmentReferenceResolver` can capture a single with-binding reference. Simple increments/decrements now reuse that reference, and new `WithStatementTests` lock in the single-lookup behavior (nested eval still exercises the old compound-assignment path and remains skipped).
- Var declarators now route initialisers through the regular assignment pipeline instead of calling `DefineFunctionScoped`, so Annex B cases like `with (o) { var foo = 1; }` update the `with` binding when the property exists and fall back to the outer var environment only when it does not. `WithStatement` also applies the spec’s `UpdateEmpty` step, so empty bodies yield `undefined` and `cptn-*` completion tests pass.
- Loop statements now call through `UpdateEmpty` as well: `EvaluateBlock` captures values even when a `break`/`continue` is pending, and `EvaluateLoopPlan` normalizes `EmptyCompletion` to `undefined`, so Annex B `cptn-abrupt-empty.js` variants in `do/while/while` no longer leak the previous completion.
- Object-environment references now hold onto a resolved binding record; each read/write replays `HasProperty` so proxy-backed `with` scopes see the precise `has`/`get` ordering (fixing the `has-binding`/`get-binding-value` logging suites and cutting `Statements_with` failures from 34 to 7).
- Object-environment bindings now detect when `Symbol.unscopables` deletes a property during resolution and remember whether the assignment should stay on the original binding. Sloppy writes flow through to the original object (matching Annex B), strict writes throw a `ReferenceError`, and deletions that happen later fall back through the environment so the typed-array and proxy `SetMutableBinding` suites are green.
- Identifier member access and call expressions now raise JavaScript `TypeError`s when targeting `null`/`undefined` receivers or non-callable values so `delete`-driven Sputnik tests can observe the abrupt completion they rely on instead of silently receiving `Symbol.Undefined`.
- Strict-mode identifier resolution no longer rejects plain `eval`/`arguments` reads; `AssignmentReferenceResolver` now enforces that restriction only when a write is attempted, so Annex B strict-code paths can call `eval` without tripping the runtime guard (`StrictMode_CanAccessGlobalEval` / `StrictMode_DirectEvalInvokesSuccessfully` lock this down).
- Annex B block-level functions now reuse the existing global/eval binding when redeclared: hoisting and runtime instantiation call through the var-binding path (configurable `CreateGlobalVarBinding`) so sloppy `$262.evalScript` snippets can replace non-configurable globals instead of throwing `TypeError: Cannot redeclare non-configurable global function`.
- Global identifier reads now prefer lexical bindings when resolving the root scope, so Annex B direct-eval block functions no longer mask subsequent `let`/`const` declarations; the Annex B global/eval suites (direct + indirect) now pass their Test262 filters.

### Next Steps
1. **Activity-backed Annex B Regression Coverage**
   - Mirror the previously failing Test262 Annex B global/eval hoist scenarios inside the internal suite, capture their Activity traces, and assert on the spans/tag payload so future regressions surface without rerunning the full Annex B filter.
2. **Parser/Evaluator Follow-ups**
   - Teach the parser about the `with (...) let` ExpressionStatement carve-out so Annex B’s `let`-as-identifier cases parse without relying on runtime fallbacks.
   - Audit helper paths (`TryFindBinding`, class field initialisers, eval-in-with) and the Annex B scope plumbing to ensure they read `ScopeMode` from the scope stack rather than reaching for global toggles.
3. **Confirm nullish member-access/call coverage**
   - Ensure the tightened nullish member-access/call behaviour is wired through optional chaining fallbacks, destructuring initialisers, and host helper paths so the Sputnik delete suite stays green.
