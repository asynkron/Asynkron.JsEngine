# Generator IR Next Steps

## Current State
- IR now includes `JumpInstruction`, `StoreResumeValueInstruction`, and a delegated `YieldStarInstruction`, so `.next/.throw/.return` payloads are captured without replaying statements and delegated iterators remain on the IR fast path.
- The builder lowers blocks, expression statements (including `yield*`), `while`, `do/while`, classic `for` loops (with labels), `if/else`, variable declarations, plain assignments (`target = yield <expr>`), simple `if (yield <expr>)` conditions, `return yield <expr>` statements, and `try/catch/finally` statements by emitting hidden slots and explicit IR instructions.
- Loop scopes track break/continue targets and now emit dedicated `BreakInstruction`/`ContinueInstruction` nodes so loop exits unwind active `finally` blocks before resuming, including across delegated `yield*` frames.
- `StoreResumeValueInstruction` consumes pending `.next/.throw/.return` payloads; `.throw`/`.return` flow through the interpreter before short-circuiting so try/catch/finally blocks can observe them, and a try-frame stack guarantees finally blocks execute during abrupt completion (including nested finalizers and mid-final `.throw/.return` overrides).
- Delegated `yield*` now awaits promise-returning iterator completions on both paths: `DelegatedYieldState.MoveNext` feeds promise-like `next/throw/return` results through `TryAwaitPromise`, and the IR `YieldStarInstruction` path now plumbs delegated `.throw/.return` completion (including async rejections) back through `HandleAbruptCompletion` and `CompleteReturn` so generators see the final completion record rather than the inner cleanup value.
- Tests `Generator_YieldStar_DelegatesValues`, `Generator_YieldStar_ReturnValueUsedByOuterGenerator`, `Generator_YieldStarReceivesSentValuesIr`, `Generator_YieldStarThrowDeliversCleanupIr`, `Generator_YieldStarReturnDeliversCleanupIr`, `Generator_YieldStarThrowContinuesWhenIteratorResumesIr`, `Generator_YieldStarThrowRequiresIteratorResultObjectIr`, `Generator_YieldStarReturnRequiresIteratorResultObjectIr`, `Generator_YieldStarThrowRequiresIteratorResultObjectInterpreter`, `Generator_YieldStarReturnRequiresIteratorResultObjectInterpreter`, `Generator_YieldStarThrowAwaitedPromiseIr`, `Generator_YieldStarThrowAwaitedPromiseInterpreter`, `Generator_YieldStarThrowPromiseRejectsIr`, `Generator_YieldStarThrowPromiseRejectsInterpreter`, `Generator_YieldStarReturnAwaitedPromiseIr`, `Generator_YieldStarReturnAwaitedPromiseInterpreter`, and `Generator_YieldStarReturnDoneFalseContinuesIr` now lock in delegated `.next/.throw/.return` semantics for synchronous iterators, promise-returning completions, and rejection propagation (IR + interpreter).
- Tests `Generator_IfConditionYieldIr` and `Generator_ReturnYieldIr` lock in IR semantics for `if (yield <expr>)` and `return yield <expr>` so resume payloads are threaded through the IR pending-completion model rather than via replay.
- `for await...of` remains on the replay path, but tests `Generator_ForAwaitFallsBackIr`, `Generator_ForAwaitAsyncIteratorAwaitsValuesIr`, `Generator_ForAwaitPromiseValuesAreAwaitedIr`, and `Generator_ForAwaitAsyncIteratorRejectsPropagatesIr` verify that async iterators and promise-valued elements are awaited and that rejections surface as `ThrowSignal`s.
- All generator IR tests, including nested `try/finally` cases (`Generator_TryFinallyNestedThrowIr`, `Generator_TryFinallyNestedReturnIr`), are now green and exercise the IR pending-completion model.
- New tests `Generator_YieldStarNestedTryFinallyThrowMidFinalIr` and `Generator_YieldStarNestedTryFinallyReturnMidFinalIr` combine `yield*` with nested `try/finally` and mid-final `.throw/.return`, and `YieldStarInstruction` now preserves pending abrupt completions across multiple `finally` frames so later resumes override earlier ones without downgrading throws/returns.
- `Generator_ForOfLetCreatesNewBindingIr_UsesIrPlan` and `Generator_ForOfDestructuringIr_UsesIrPlan` now lock in that `for...of` with block-scoped bindings (including destructuring and closures) is hosted on the IR path.
- The replay-based generator path has been removed: `TypedGeneratorInstance` now requires `GeneratorIrBuilder.TryBuild` to succeed and throws a `NotSupportedException` with a detailed reason when IR construction fails.
- Gap-coverage tests `Generator_VariableInitializerWithMultipleYields_UnsupportedIr`, `Generator_IfConditionComplexYield_UnsupportedIr`, `Generator_ForConditionYield_UnsupportedIr`, `Generator_WhileConditionYield_UnsupportedIr`, `Generator_DoWhileConditionYield_UnsupportedIr`, `Generator_ForIncrementYield_UnsupportedIr`, and `Generator_SwitchStatement_UnsupportedIr` now document the remaining unsupported `yield` placements and switch statements in generators by asserting clear failure reasons from `GeneratorIrDiagnostics`.
- `GeneratorIrDiagnostics` exposes lightweight counters for IR plan attempts/successes/failures, and `Generator_ForOfYieldsValuesIr_UsesIrPlan` asserts that plain `for...of` with `var` is always hosted on the IR path (no silent fallbacks).
- `docs/GENERATOR_IR_LIMITATIONS.md` captures which generator constructs lower to IR, which ones intentionally fall back, and what follow-up work is still open.
- Date instances now use the constructor-created prototype chain instead of copying methods, fixing the `date-format-xparb.js` SunSpider failure caused by `this[func]()` seeing an undefined prototype method, and keeping dynamically-added `Date.prototype` methods visible to existing instances.
- A minimal `Function` constructor and `Function.call` helper have been added so patterns like `Function.call.bind(Object.prototype.hasOwnProperty)` behave as expected, and a stub `localStorage` object is exposed globally so `babel-standalone.js` can probe storage without throwing.
- Program-level and function-level function declarations are now hoisted via `HoistVarDeclarations`/`HoistFromStatement`, so cases like `exports.formatArgs = formatArgs;` before the `function formatArgs(...) {}` body in Babel’s bundled `debug` module resolve correctly rather than throwing `Undefined symbol` at module initialisation.

## Next Iteration Plan

1. **Normalize Symbol/Iterator Semantics for Babel/Regenerator**
   - Extract a minimal repro of Babel’s `_createForOfIteratorHelperLoose` and the regenerator `runtime_1` block (particularly `iteratorSymbol = $Symbol.iterator || "@@iterator"` and `IteratorPrototype[iteratorSymbol] = …`) and run it in isolation against the engine.
   - Instrument `TypedAstEvaluator` and `JsOps.TryGetPropertyValue` to log `o[Symbol.iterator]` / `o["@@iterator"]` lookups for the repro, so we can see exactly when a truthy, non-callable internal `Symbol` is being exposed instead of a function or `undefined`.
   - Ensure that for arrays, strings, regenerator-style iterator prototypes, and async iterator helpers, the engine always stores iterator methods as callable values under the correct symbol-keyed property (and never exposes internal `Ast.Symbol` instances as iterator values).
   - Tighten symbol-keyed property resolution so `o[Symbol.iterator]` / `o[Symbol.asyncIterator]` either resolve to a callable `IJsCallable` or are treated as `undefined`, allowing Babel’s helpers to fall back cleanly to `@@iterator`/array-like code paths instead of attempting to call a non-callable sentinel.
   - Validate the changes against the minimal repro and then against the SunSpider/Babel tests, updating documentation to record the new iterator semantics and any remaining limitations. (In progress: `_createForOfIteratorHelperLoose` now passes via `BabelIteratorHelperTests`, and `babel-standalone.js` no longer fails on `arguments`, `this`, or iterator helpers, but still trips the debug integration around `createDebug.enable(createDebug.load())` and uses of `createDebug.formatArgs`.)

2. **Grow IR Coverage for Unsupported Generator Shapes**
   - Use the new `_UnsupportedIr` tests (variable initialisers with multiple `yield`s, complex loop conditions/increments, and `switch` statements) as a checklist for extending `SyncGeneratorIrBuilder` and the IR interpreter to cover more `yield` placements.
   - As individual shapes become supported on the IR path, convert the corresponding tests from `_UnsupportedIr` to `*Ir` / `*Ir_UsesIrPlan` variants and update `docs/GENERATOR_IR_LIMITATIONS.md` accordingly.

3. **Introduce Async Generator IR**
   - Replace the `AsyncGeneratorIrBuilder` placeholder with a real IR lowering for async generator functions so `for await...of` loops and async iterator patterns can run on the IR path rather than the legacy evaluator.
   - Extend the async iteration tests to assert IR usage via `GeneratorIrDiagnostics` once async generator IR is in place.

4. **Async Await Scheduling**
   - Revisit `TryAwaitPromise` and generator scheduling now that the replay generator path has been removed:
     - Integrate the event queue (e.g., resume generators via `ScheduleTask`) so long-running promises in generators don’t block the managed thread.
     - Optionally expose instrumentation hooks (trace or debug) so we can observe nested awaits inside generators and detect potential starvation.
