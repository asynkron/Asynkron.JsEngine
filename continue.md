# Generator IR Next Steps

## Current State
- Generator yield lowering now normalizes declarations, assignments, returns, conditionals, and `for` conditions/increments into `__yield_lower_*` temps (`let __yield_lower...; __yield_lower... = yield ...;`) so `SyncGeneratorIrBuilder` only sees yield-free conditions/increments and recognizes those temp assignments as yield points to store resume payloads.
- Loop scopes track break/continue targets and now emit dedicated `BreakInstruction`/`ContinueInstruction` nodes so loop exits unwind active `finally` blocks before resuming, including across delegated `yield*` frames.
- `StoreResumeValueInstruction` consumes pending `.next/.throw/.return` payloads; `.throw`/`.return` flow through the interpreter before short-circuiting so try/catch/finally blocks can observe them, and a try-frame stack guarantees finally blocks execute during abrupt completion (including nested finalizers and mid-final `.throw/.return` overrides).
- Delegated `yield*` now awaits promise-returning iterator completions on both paths: `DelegatedYieldState.MoveNext` feeds promise-like `next/throw/return` results through `TryAwaitPromise`, and the IR `YieldStarInstruction` path now plumbs delegated `.throw/.return` completion (including async rejections) back through `HandleAbruptCompletion` and `CompleteReturn` so generators see the final completion record rather than the inner cleanup value.
- Tests `Generator_YieldStar_DelegatesValues`, `Generator_YieldStar_ReturnValueUsedByOuterGenerator`, `Generator_YieldStarReceivesSentValuesIr`, `Generator_YieldStarThrowDeliversCleanupIr`, `Generator_YieldStarReturnDeliversCleanupIr`, `Generator_YieldStarThrowContinuesWhenIteratorResumesIr`, `Generator_YieldStarThrowRequiresIteratorResultObjectIr`, `Generator_YieldStarReturnRequiresIteratorResultObjectIr`, `Generator_YieldStarThrowRequiresIteratorResultObjectInterpreter`, `Generator_YieldStarReturnRequiresIteratorResultObjectInterpreter`, `Generator_YieldStarThrowAwaitedPromiseIr`, `Generator_YieldStarThrowAwaitedPromiseInterpreter`, `Generator_YieldStarThrowPromiseRejectsIr`, `Generator_YieldStarThrowPromiseRejectsInterpreter`, `Generator_YieldStarReturnAwaitedPromiseIr`, `Generator_YieldStarReturnAwaitedPromiseInterpreter`, and `Generator_YieldStarReturnDoneFalseContinuesIr` now lock in delegated `.next/.throw/.return` semantics for synchronous iterators, promise-returning completions, and rejection propagation (IR + interpreter).
- IR now includes `JumpInstruction`, `StoreResumeValueInstruction`, and a delegated `YieldStarInstruction`, so `.next/.throw/.return` payloads are captured without replaying statements and delegated iterators remain on the IR fast path.
- Tests `Generator_IfConditionYieldIr` and `Generator_ReturnYieldIr` lock in IR semantics for `if (yield <expr>)` and `return yield <expr>` so resume payloads are threaded through the IR pending-completion model rather than via any replay-style execution.
- `for await...of` continues to run on the non-IR async/CPS pipeline, but tests `Generator_ForAwaitFallsBackIr`, `Generator_ForAwaitAsyncIteratorAwaitsValuesIr`, `Generator_ForAwaitPromiseValuesAreAwaitedIr`, and `Generator_ForAwaitAsyncIteratorRejectsPropagatesIr` verify that async iterators and promise-valued elements are awaited and that rejections surface as `ThrowSignal`s.
- All generator IR tests, including nested `try/finally` cases (`Generator_TryFinallyNestedThrowIr`, `Generator_TryFinallyNestedReturnIr`), are now green and exercise the IR pending-completion model.
- New tests `Generator_YieldStarNestedTryFinallyThrowMidFinalIr` and `Generator_YieldStarNestedTryFinallyReturnMidFinalIr` combine `yield*` with nested `try/finally` and mid-final `.throw/.return`, and `YieldStarInstruction` now preserves pending abrupt completions across multiple `finally` frames so later resumes override earlier ones without downgrading throws/returns.
- `Generator_ForOfLetCreatesNewBindingIr_UsesIrPlan` and `Generator_ForOfDestructuringIr_UsesIrPlan` now lock in that `for...of` with block-scoped bindings (including destructuring and closures) is hosted on the IR path.
- The replay-based generator path has been removed: `TypedGeneratorInstance` now requires `GeneratorIrBuilder.TryBuild` to succeed and throws a `NotSupportedException` with a detailed reason when IR construction fails.
- `Generator_SwitchStatementIr_UsesIrPlan` and `Generator_SwitchStatementSemanticsIr` now lock in IR-backed `switch` semantics inside generators for yield-free discriminants/tests, a single default clause in the final position, and simple trailing `break;` per case (with fallthrough preserved).
- `Generator_ForIncrementYieldIr_UsesIrPlan` now locks in IR support for `for` loops whose increment expression contains a single non-delegated `yield` (e.g. `i = i + (yield "step")`), using a hidden resume slot so the increment expression consumes the resume value on each iteration.
- `Generator_VariableInitializerWithMultipleYieldsIr_UsesIrPlan` now locks in IR support for variable initializers that are binary expressions whose left/right operands are simple (non-delegated) `yield` expressions with yield-free operands (e.g. `let value = (yield "a") + (yield "b");`), by rewriting the initializer to read from two hidden resume slots and emitting the corresponding yields in source order.
- Gap-coverage tests `Generator_ForIncrementMultipleYields_UnsupportedIr` and `Generator_SwitchStatement_UnsupportedIr` now document the remaining unsupported `yield` placements and complex `switch` layouts in generators (e.g. multiple yields in a single increment expression or non-tail/multiple defaults) by asserting clear failure reasons from `GeneratorIrDiagnostics`.
- `GeneratorIrDiagnostics` exposes lightweight counters for IR plan attempts/successes/failures, and `Generator_ForOfYieldsValuesIr_UsesIrPlan` asserts that plain `for...of` with `var` is always hosted on the IR path (no silent fallbacks). The `_UnsupportedIr` tests now exercise specific unsupported shapes without relying on global attempt counts, reducing flakiness when unrelated generators run in the same test session.
- `docs/GENERATOR_IR_LIMITATIONS.md` captures which generator constructs lower to IR, which ones intentionally fall back, and what follow-up work is still open.
- `docs/UNIFIED_CONTROL_FLOW_BUILDING_BLOCKS.md` outlines shared visitors/loop plans/await schedulers to deduplicate loop/yield/await handling across the lowerer, IR builders, and the typed evaluator.
- Shared `AstShapeAnalyzer` now owns yield/await detection and single-yield rewrites; generator lowering, generator IR building, and `TypedCpsTransformer` now consume it instead of bespoke `ContainsYield` visitors.
- Loop normalization scaffolding (`LoopPlan` + `LoopNormalizer`) is in place, and `SyncGeneratorIrBuilder` now builds while/do/for via LoopPlan; lowerer/evaluator loop runners still need to adopt it.
- Generator yield lowering now uses `LoopPlan` for while/do/for rewrites, and the typed evaluator runs while/do/for via `LoopPlan`, paving the way for shared loop handling across the stack.
- Iterator driver scaffolding exists (`IteratorDriverPlan`/`IteratorDriverState`); the generator IR executor now runs `for...of`/`for await...of` via shared `IteratorInit`/`IteratorMoveNext` instructions and the driver state instead of bespoke `ForOfState`/`ForAwaitStage` bookkeeping. The IR builder now constructs iterator bodies from `IteratorDriverPlan` but still hand-assembles the instruction sequence instead of using a shared template.
- Await handling is now centralized in `AwaitScheduler` so the evaluator and iterator drivers share the same blocking vs pending behaviour; semantics are unchanged, but this gives us one place to evolve into a non-blocking scheduler.
- Date instances now use the constructor-created prototype chain instead of copying methods, fixing the `date-format-xparb.js` SunSpider failure caused by `this[func]()` seeing an undefined prototype method, and keeping dynamically-added `Date.prototype` methods visible to existing instances.
- A minimal `Function` constructor and `Function.call` helper have been added so patterns like `Function.call.bind(Object.prototype.hasOwnProperty)` behave as expected, and a stub `localStorage` object is exposed globally so `babel-standalone.js` can probe storage without throwing.
- `instanceof` now follows `@@hasInstance`/`OrdinaryHasInstance` semantics (including the well-known `Symbol.hasInstance`), `Function.prototype[@@hasInstance]` throws when `prototype` is non-object, and the `LanguageTests.Expressions_instanceof` suite is green aside from the explicitly excluded prototype-getter and TCO cases.
- A dynamic call-depth guard (default 1000) now wraps JS invocations to fail fast on runaway recursion; promise callbacks still recurse synchronously and need the guard propagated through the promise scheduler to cover async iterator edge cases.
- Promise handler invocation is now scheduled onto the engine event queue instead of recursing synchronously, so deep promise chains (including async iterator helpers) unwind the C# call stack between steps instead of overflowing.
- Program-level and function-level function declarations are now hoisted via `HoistVarDeclarations`/`HoistFromStatement`, so cases like `exports.formatArgs = formatArgs;` before the `function formatArgs(...) {}` body in Babel’s bundled `debug` module resolve correctly rather than throwing `Undefined symbol` at module initialisation.
- `Date` built-ins now expose a more complete surface for common usage patterns: `Date.UTC` matches Node’s millisecond outputs (including the 0–99 year offset behaviour), instances support both local (`getFullYear` etc.) and UTC getters (`getUTCFullYear` etc.), and formatting helpers (`toISOString`, `toUTCString`, `toJSON`, `valueOf`) behave consistently with Node for ISO and UTC strings.
- `async function*` is now wired into the typed evaluator: async generator functions are created via `AsyncGeneratorFactory` / `AsyncGeneratorInstance`, which internally reuse the sync generator IR plan and wrap the iterator protocol (`next`/`return`/`throw`) in Promises so async generator tests (covering loops, `switch`, `try/catch/finally`, and `yield*`) run on the IR path.
- `await` expressions in typed AST and async iterator helpers rely on a shared `TryAwaitPromise` helper that synchronously blocks on promise-like values; `EvaluateAwait` now delegates to `TryAwaitPromise` so `await` inside `async function*` bodies (including in `while` / `do/while` loops) resolves promise-like values before each `yield`, and async generator tests `AsyncGenerator_AwaitsBeforeYield` / `AsyncGenerator_WhileAndDoWhileWithAwaitAndYield` are green.

# Next Iteration Plan

1. **Grow IR Coverage for Remaining Unsupported Generator Shapes**
   - Use the `_UnsupportedIr` tests (complex `yield` in increments and complex `switch` layouts) as the driver for extending the normalized surface and the IR interpreter once lowering is in place.
   - As shapes become supported, flip the corresponding tests to `*Ir` / `*Ir_UsesIrPlan` variants and update `docs/GENERATOR_IR_LIMITATIONS.md`.
2. **Async Generator IR + Non-Blocking Await (Real Thing)**
   - Async generators now reuse the sync generator IR plan via `TypedGeneratorInstance`, surface pending promises from `await` expressions and `for await...of` loops through `AsyncGeneratorStepResult.Pending`, and resume via `AsyncGeneratorInstance` using the engine’s event queue. Nested awaits inside async generators (including `__delay`) and `for await...of` inside async generator bodies are hosted on the non-blocking IR path.
   - **Unify async iteration paths**
     - Replace remaining uses of the blocking `TryAwaitPromise` helper in non-IR async iteration (`EvaluateForAwaitOf`, CPS async helpers) with the non-blocking `TryAwaitPromiseOrSchedule` + event-queue model so plain `async function` + `for await...of` can safely use `__delay(1)` without thread blocking.
   - **Diagnostics and tests**
     - Extend `AsyncGeneratorTests` and `AsyncIterationTests` with cases that detect real non-blocking behaviour (including `__delay(1)` in both async functions and async generators) and add async-aware diagnostics so we can assert that async generators and `for await...of` loops are using the IR + pending-promise executor rather than any legacy blocking behaviour.
3. **Broaden lowerer coverage and tests**
   - Add unit tests around the normalized conditional/`for` rewrites and any remaining multi-yield expressions to lock in the new lowering surface and guard against regressions as more IR shapes are added.
4. **Unify control-flow building blocks**
   - Next steps from `docs/UNIFIED_CONTROL_FLOW_BUILDING_BLOCKS.md`: finish unifying iterator handling by reusing the shared `IteratorDriverPlan` template in the IR builder (instead of assembling per-iteration blocks manually), then move on to non-blocking await scheduling and the shared rollback/loop helpers. Await handling is now centralized via `AwaitScheduler`, and async generators surface pending promises to `AsyncGeneratorInstance`; plain async functions/other iterator paths still need the non-blocking scheduler wired in.
5. **Harden recursion/overflow handling**
   - Promise callbacks now run via the event queue to avoid synchronous recursion. Follow up by threading call-depth diagnostics through the async scheduler so remaining re-entry paths are covered and we can add a regression test.

---

## Annex B Scope Modes

### Current State
- `EvaluationContext` now tracks `ScopeMode` frames (`Strict`, `Sloppy`, `SloppyAnnexB`), and `RealmState.CreateContext` produces pre-scoped strict contexts for host helpers so sloppy vs Annex B semantics flow through the scope stack.
- The realm context factory now supports cancellation/execution options, and all runtime helpers (program + function invocation) use it instead of `new EvaluationContext`, so scope stacks are created uniformly.
- Standard library helpers (String/Number/JSON/Array/Function), typed arrays, and `JsArgumentsObject` all rely on the realm factory instead of hand-rolling `EvaluationContext`, so coercion helpers automatically inherit the correct strict/Annex B behaviour.
- Generator execution contexts (both IR-backed and fallback) use the same factory, and Annex B block instantiation during hoisting now keys off `context.CurrentScope.AllowAnnexB` instead of global option checks.
- `AnnexBOptionsTests` now cover lexical/parameter blocking, loop-scoped functions, and nested eval inside loops so Annex B toggles are validated across more control-flow shapes.

### Next Steps
1. **Parser/Evaluator Awareness**
   - Audit the parser and evaluator helpers that still peek at lexical environments directly (e.g. `TryFindBinding`, class field initialisation, Annex B diagnostics) and thread `ScopeMode` / evaluation context data so all sloppy vs Annex B behaviour is scope-driven.
2. **Annex B Toggle Tests**
   - Extend regression coverage to remaining shapes (e.g. block functions inside `switch`/`try`, nested `with` + eval combos) and add module/eval integration cases so Annex B enable/disable behaviour stays guarded beyond loops.
